// 2肯定是在首位的，因为2必须在3的前面，而0必须在1的前面，而且0不能在首位，那么显而易见的首位只能是2.

// 这题是典型的数位dp，第 n 位可以利用第 n-1 位的结果， 将其分为6种状态如下：

// 1. 只含2            =>   222_2
// 2. 只含2、0         =>   222_0、  2020_2、 2020_0
// 3. 只含2、3         =>   2233_3、222_3
// 4. 只含2、0、1      =>   2200_1、220011_2、220011_1
// 5. 只含2、0、3      =>   2233_0、2200_3、223300_0、223300_3
// 6. 含4种数字        =>    201_3、203_1、2013_3、 2013_1、2031_1、2031_3

// dp[i][j]表示位数为 i，符合状态 j 的（6种）合法的数的个数。
// 对于状态1: dp[i][1] = 1   因为只有一种可能
// 对于状态2: dp[i][2] = dp[i-1][1] + dp[i-1][2] * 2
//     位数为 i 且只含 2、0 的整数可以由位数为 i-1 的只含 2 的数在末尾添加0 得到，也可以通过 位数 i-1 的只含0、2 的数在末尾添加 0或2 组成
// 对于转态3：dp[i][3] = dp[i-1][1] + dp[i-1][3]
//     位数为i 且只含2、3 的整数可以由 位数为 i-1 的只含 2 的数在末尾添加3得到，也可以通过位数为 i-1 的 只含2、3的整数 在末尾添加3得到
//     注： 数字2必须在3之前
// 对于状态4: dp[i][4] = dp[i-1][2] + dp[i-1][4] * 2
// 对于状态5：dp[i][5] = dp[i-1][2] + dp[i-1][3] + dp[i-1][5] * 2
// 对于状态6：dp[i][6] = dp[i-1][4] + dp[i-1][5] + dp[i-1][6] * 2
#include <iostream>
#include <cstring>
using namespace std;
#define mod 1000000007
long long dp[1001][7];
int main() {
    memset(dp, 0, sizeof dp);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        //2+2/0,3;
        //20+0,2/1,3;23+3/0;
        //201+1,2/3;203+0,3/1;
        //0123+1,3;
        dp[i][0] = 1;
        dp[i][1] = (dp[i-1][1] * 2 + dp[i-1][0]) % mod;
        dp[i][2] = (dp[i-1][2] + dp[i-1][0]) % mod;
        dp[i][3] = (dp[i-1][3] * 2 + dp[i-1][1]) % mod;
        dp[i][4] = (dp[i-1][4] * 2 + dp[i-1][1] + dp[i-1][2]) % mod;
        dp[i][5] = (dp[i-1][5] * 2 + dp[i-1][3] + dp[i-1][4]) % mod;
        //cout<<dp[i][0]<<" "<<dp[i][1]<<" "<<dp[i][2]<<" "<<dp[i][3]<<" "<<dp[i][4]<<" "<<dp[i][5]<<endl;
    }
    cout<<dp[n][5]<<endl;
    return 0;
}
